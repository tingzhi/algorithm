\documentclass[11pt]{scrreprt}
\usepackage[utf8]{inputenc}

\title{\textbf{Project 2 Report}}
\subtitle{CS325 Analysis of Algorithms, Summer 2015}
\author{\textsf{\textbf{Project Group 1}}\\
		\textsf{Tingzhi Li}\\
		\textsf{Nicholas Nelson}\\
		\textsf{Chunyang Zhang}}
		
\usepackage{graphicx}

\usepackage{listings} %插入代码
\usepackage{xcolor} %代码高亮

\lstset{numbers=left, %设置行号位置
	numberstyle=\tiny, %设置行号大小
	keywordstyle=\color{blue}, %设置关键字颜色
	commentstyle=\color[cmyk]{1,0,1,0}, %设置注释颜色
	frame=single, %设置边框格式
	escapeinside=``, %逃逸字符(1左面的键)，用于显示中文
	breaklines, %自动折行
	extendedchars=false, %解决代码跨页时，章节标题，页眉等汉字不显示的问题
	xleftmargin=2em,xrightmargin=2em, aboveskip=1em, %设置边距
	tabsize=4, %设置tab空格数
	showspaces=false %不显示空格
}

%\usepackage[demo]{graphicx}
\usepackage{caption}
\usepackage[labelformat=simple]{subcaption}
\renewcommand\thesubfigure{(\alph{subfigure})} % see subcaption doc


\date{}
\begin{document}

\maketitle

\chapter{Theoretical Analysis}

\section{Dynamic Programming Table Filling Logic}

In this dynamic programming algorithm, its table is consisit of avaiable coins as column header and change as row header. The actual minimum number of coins for that particular change will be filled in the table accordingly. The base case of this table is $T[0]=0$, which means the first row will be filled with zeroes. For $T[1]$ we need to look up $T[1-V[i]]$ where $v[i]\leq 1$. Same logic applied to all the following cases.

For example, if our avaiable coins are [1,2,5,10], $A=5$. Then the table would look like the following.

\begin{tabular}{|c|c|c|c|c|}
	\hline & \multicolumn{4}{|c|}{Avaiable coins' value} \\
	\hline Change & 1  & 1, 2 & 1, 2, 5 & 1, 2, 5, 10 \\ 
	\hline 0 & 0 & 0 & 0 & 0 \\ 
	\hline 1 & 1 & 1 & 1 & 1 \\ 
	\hline 2 & 2 & 1 & 1 & 1 \\ 
	\hline 3 & 3 & 2 & 2 & 2 \\ 
	\hline 4 & 4 & 2 & 2 & 2 \\ 
	\hline 5 & 5 & 3 & 1 & 1 \\ 
	\hline 
\end{tabular} 

Since we start to fill in the table from base case, for each step we could guarantee that the optimal number of coins we need for that particular change is found. So in the end, we could be sure that the number of coins we need for our target change is optimal as well.

\section{Pseudo-Code for Three Algorithms}
\subsection {Brute Force Algorithm}

\begin{lstlisting}[language=c]
function changeslow(V[n],A){
	C[n] = [0,...,0]
	for (j = 0; j < n; j++){
		if (A == V[j]){
			m = 1
			C[j] += 1
			return m, C[n]
	}
	min = A
	for (i = 1; i < A; i++){
		m1, c1[n] = changeslow(V[n], i)
		m2, c2[n] = changeslow(V[n], A - i)
		m = m1 + m2
		c[n] = c1[n] + c2[n]
		if (min > m){
			min = m
			Cmin[n] = c[n]
		}
	}
	return min, Cmin[n]
}
\end{lstlisting}
In this algorithm, the running-time complexity is
\begin{eqnarray*}
T(n) 	& = & (T(1)+ T(n-1)) + (T(2) + T(n-2)) + ... + (T(n-1) + T(1)) + c\\
		& = & 2(T(1) + T(2) + T(3) + ... + T(n-1)) + c\\
T(1)	& = & c\\
T(2) 	& = & 2T(1) + c\\
T(3) 	& = & 2(1+2)T(1) + (1+2)c\\
T(4) 	& = & 2(1+2+2(1+2))T(1) + (1+2+4)c\\
	 	& = & (2+4)(1+2)T(1) + (1+2+4)c\\
T(5) 	& = & (2+4+8)(1+2)T(1) + (1+2+4+8)c\\
		& . & \\
		& . & \\
		& . & \\
T(n) 	& = & (2+4+8+16+..+2^{n-2})(1+2)T(1) + (1+2+4+8+...+2^{n-2})c\\
		& = & (2^{n-1}-2)T(1) + 2^{n-1}c\\
		& = & (2^n-2)c\\
		& = & \Theta(2^n)\\
\end{eqnarray*}
Note that the n is the value of the amount needed to be changed, but not the index number of the list.



\subsection{Greedy Algorithm}

\begin{lstlisting}[language=c]
function changegreedy(V[n],A) {
	reverse(V[n])
	c[n] = [0,...,0]
	for (i = 0; i < n; i++){
		temp = A - V[i]
		while (temp >= 0){
		    A = temp
		    c[i] += 1
		    m += 1
		    temp = A - V[i]
		}
	}
	return c, m
}
\end{lstlisting}

In this algorithm, the running-time complexity is
\begin{eqnarray*}
T(n) = \Theta(n), where n is the amount needed to be changed.
\end{eqnarray*}

\subsection{Dynamic Programming}

\begin{lstlisting}[language=c]
function changedp(V[n], A){
	c[A][n] = [[0,...,0],...,[0,...,0]]
	T[A] = [0,...,0]
	temp[n] = [0,...,0]
	for (i = 1; i <= A; i++){
		for (j = 0; j < n; j++){
			k = j - V[j]
			if (k >= 0){
				temp[j] = T[k] + 1
		T[i] = min(temp[j])				\\The index of the minimum value of array temp is j.
		c[i][j] = c[k][j] + 1
	}
	return c[A], T[A]
}
\end{lstlisting}

In this algorithm, the running-time complexity is
\begin{eqnarray*}
T(n) = \Theta(nA), where n is the number of different coins and A is the amount needed to be changed.
\end{eqnarray*}


\chapter{Experimental Analysis}

\section{Situation 1}

\section{Situation 2}

\section{Situation 3}

\section{Running Time Comparison}

\section{Exploring Relationship Between Running Time and Number of Denominations}

\section{Special Coins' Value Case}





\end{document}
