\documentclass[11pt]{scrreprt}
\usepackage[utf8]{inputenc}

\title{\textbf{Project 1 Report}}
\subtitle{CS325 Analysis of Algorithms, Summer 2015}
\author{\textbf{Project Group 1}\\
		Tingzhi Li\\
		Nicholas Nelson\\
		Chunyang Zhang}

\usepackage{listings} %插入代码
\usepackage{xcolor} %代码高亮

\lstset{numbers=left, %设置行号位置
	numberstyle=\tiny, %设置行号大小
	keywordstyle=\color{blue}, %设置关键字颜色
	commentstyle=\color[cmyk]{1,0,1,0}, %设置注释颜色
	frame=single, %设置边框格式
	escapeinside=``, %逃逸字符(1左面的键)，用于显示中文
	breaklines, %自动折行
	extendedchars=false, %解决代码跨页时，章节标题，页眉等汉字不显示的问题
	xleftmargin=2em,xrightmargin=2em, aboveskip=1em, %设置边距
	tabsize=4, %设置tab空格数
	showspaces=false %不显示空格
}

\date{}
\begin{document}

\maketitle

\chapter{Theoretical Run-time Analysis}

\textbf{1. Pseudo-Code}\\\\
\textit{1.1 Enumeration Algorithm}\\

\begin{lstlisting}[language=c]
function enumeration(a[n]) {
	max = a[0];
	for (i = 0; i < n; i++) {
		for (j = i; j < n; j++) {
			sum = sum(a[i:j]);
			if (sum > max)
				max = sum;
		}
	}
}
\end{lstlisting}

In this algorithm, since sum = sum(a[i:j]) costs $\Theta(n)$ because potentially this sum is an [i to j] loop. So the running-time complexity is
\begin{eqnarray*}
T(n) = \Theta(n^3)
\end{eqnarray*}
\textit{1.2 Better Enumeration Algorithm}\\

\begin{lstlisting}[language=c]
function beter_enumeration(a[n]) {
	max = a[0];
	for (i = 0; i < n; i++) {
		sum = 0;
		for (j = i; j < n; j++) {
			sum = sum + a[j];
			if (sum > max)
				max = sum;
		}
	}
	return max;
}
\end{lstlisting}

In this algorithm, the running-time complexity is
\begin{eqnarray*}
T(n) = \Theta(n^2)
\end{eqnarray*}
\textit{1.3 Divide and Conquer Algorithm}

\begin{lstlisting}[language=c]
function deivde_n_conquer(a[n]) {
	devide_n_conquer(a[n/2]);
	devide_n_conquer(a[n/2]);
	
	/*right half method*/
	sum = 0; rightmax = a[0];
	for (i = 0; i < n; i++) {
		sum = sum + a[i];
		if (sum > rightmax)
			rightmax = sum;
	}
	
	/*left half method*/
	sum = 0; leftmax = a[n];
	for (i = n; i > 0; i--) {
		sum = sum + a[i];
		if (sum > leftmax)
			leftmax = sum;
	}
	
	/*merge together after finding the max*/
	max = max(leftmax, rightmax, rightmax + leftmax);
	return max;
}
\end{lstlisting}

In this algorithm, the running-time complexity is
\begin{eqnarray*}
T(n) 	& = & 2T(n/2)+n\\
		& = & 4T(n/4)+2n\\
		& = & 8T(n/8)+3n\\
		& = & ......\\
		& = & nT(1)+nlg(n)\\
		& = & \Theta(nlg(n))\\\\\\\\\\\\
\end{eqnarray*}
\textit{1.4 Linear-time Algorithm}\\

\begin{lstlisting}[language=c]
function linear_time(a[n]) {
	sum = max = 0;
	for (i = 0; i < n; i++) {
		sum = sum + a[i];
		if (sum > 0) {
			if (sum > max)
				max = sum;
		}
		else
			sum = 0;
	}
	return max;
}
\end{lstlisting}

In this algorithm, the running-time complexity is
\begin{eqnarray*}
T(n) = \Theta(n)\\
\end{eqnarray*}
\textbf{2. Analysis of the Asymptotic Running-times}\\

Accordingly, the list of the running time complexity is shown as follows.
\begin{eqnarray*}
Enumeration Algorithm&:& \Theta(n^3)\\
Better Enumeration Algorithm&:& \Theta(n^2)\\
Divide And Conquer Algorithm&:& \Theta(nlg(n))\\
Linear-time Algorithm&:& \Theta(n)
\end{eqnarray*}

Compare with these four algorithms, we can see that for a large n, the Linear-time algorithm has the best running time complexity which is $\Theta(n)$, while the enumeration algorithm ($\Theta(n^3)$) is the worst.

So the order for these algorithms from the best to the worst could be 
\begin{eqnarray*}
Linear-time > Divide And Conquer > Better Enumeration > Enumeration
\end{eqnarray*}

\chapter{Proof of Correctness}

Divide and conquer algorithm

\begin{lstlisting}[language=c,mathescape=true]
/*
Precondition: 
Array A has at least one element between indices front and end. (front < end)
Postcondition: 
The maximum subarray of n elements is found. 
*/

divideAndConquer(A[], front, end)
	if (front < end)
		mid = $\lfloor$(front+end)/2$\rfloor$
		left = divideAndConquer(A[], front, mid)
		right = divideAndConquer(A[], mid+1, end)
		comb = combination(A[], front, mid, end)		
		//finding maximum subarray from mid to front and from mid to end.
		return max(left, right, comb)
		
/*
For combination(A[], front, mid, end) function:
Precondition: 
A is an array and front, mid, and end are indices into the array such that front <= mid < end.
Postcondition: 
The maximum subarray combining a subarray from mid to front and a subarray from mid to end is found.
*/
\end{lstlisting}
\emph{Base Case:} 

$n = 1$, n represents number of elements in the array A[ ]. A[ ] contains a single element, which will just return the value of the element. \\
\emph{Inductive Hypothesis:} 

Assume that DivideAndConquer correctly finds the maximum subarray of $n=1, 2,\cdots, k$ elements. \\
\emph{Inductive Step:} 

Show that DivideAndConquer will correctly finds the maximum subarray of $n= k+1$ elements. 

First recursive call $n_1=(k+1)/2\leq k\Rightarrow $ Maximum subarray of \textit{A[front, mid]} is found.

Second recursive call $n_2=(k+1)/2 \leq k \Rightarrow$ Maximum subarray of \textit{A[mid+1, end]} is found.

Now \textit{A[ ]}, \textit{front}, \textit{mid}, \textit{end} fulfill the precondition of \textit{combination()} function.

The postcondition of \textit{combination()} function guarantees that the maximum subarray from a suffix of the first half(\textit{A[front, mid]}) and a prefix of the second half(\textit{A[mid+1, end]}) is found.

The final return guarantees that the maximum subarray of \textit{A[front, end]} is found. \\
\emph{Termination:}

We find that array size decreases with every recursive call. For the base case, there is one element in the array. The algorithm terminates in this case without making additional recursive calls.


\chapter{Testing}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vitae quam ut est luctus pellentesque at a orci. Nam metus nibh, condimentum blandit tellus ut, mollis dapibus ligula. Mauris gravida nulla ac ultrices luctus. Maecenas consectetur ex nulla, euismod tristique nulla interdum vel. Donec lorem quam, tincidunt quis volutpat quis, dignissim suscipit sapien. Ut interdum nunc magna, ultrices consectetur massa efficitur ut. Praesent ante augue, rhoncus nec pellentesque vitae, condimentum ultrices metus. Duis sapien ex, pretium ut magna in, pellentesque ultrices sapien. Sed imperdiet lacus non risus venenatis, vitae convallis nibh eleifend. Nulla ornare odio sit amet dolor efficitur, eu facilisis velit consectetur. Nulla facilisi. Integer nec sem rutrum mauris ornare pellentesque vel commodo ipsum.

Cras vulputate placerat lorem id lacinia. Etiam vulputate ipsum ex. Aenean et neque sodales, consequat tellus et, congue velit. Nunc facilisis aliquet tortor eget consequat. In tincidunt in eros sit amet euismod. Donec quis consequat libero. Nullam et maximus risus. Sed non velit pellentesque, sagittis risus sit amet, rutrum risus. Vestibulum congue eu elit et facilisis. Aliquam at erat sed turpis commodo lobortis. Morbi sed egestas est, sit amet ornare arcu. Morbi vel erat vitae nisi tempus elementum. Etiam sit amet aliquet elit. Aenean at mi eu purus congue congue. Curabitur pulvinar suscipit diam et porttitor. Quisque nec porta ipsum. 


\chapter{Experimental Analysis}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vitae quam ut est luctus pellentesque at a orci. Nam metus nibh, condimentum blandit tellus ut, mollis dapibus ligula. Mauris gravida nulla ac ultrices luctus. Maecenas consectetur ex nulla, euismod tristique nulla interdum vel. Donec lorem quam, tincidunt quis volutpat quis, dignissim suscipit sapien. Ut interdum nunc magna, ultrices consectetur massa efficitur ut. Praesent ante augue, rhoncus nec pellentesque vitae, condimentum ultrices metus. Duis sapien ex, pretium ut magna in, pellentesque ultrices sapien. Sed imperdiet lacus non risus venenatis, vitae convallis nibh eleifend. Nulla ornare odio sit amet dolor efficitur, eu facilisis velit consectetur. Nulla facilisi. Integer nec sem rutrum mauris ornare pellentesque vel commodo ipsum.

Cras vulputate placerat lorem id lacinia. Etiam vulputate ipsum ex. Aenean et neque sodales, consequat tellus et, congue velit. Nunc facilisis aliquet tortor eget consequat. In tincidunt in eros sit amet euismod. Donec quis consequat libero. Nullam et maximus risus. Sed non velit pellentesque, sagittis risus sit amet, rutrum risus. Vestibulum congue eu elit et facilisis. Aliquam at erat sed turpis commodo lobortis. Morbi sed egestas est, sit amet ornare arcu. Morbi vel erat vitae nisi tempus elementum. Etiam sit amet aliquet elit. Aenean at mi eu purus congue congue. Curabitur pulvinar suscipit diam et porttitor. Quisque nec porta ipsum. 

\end{document}
